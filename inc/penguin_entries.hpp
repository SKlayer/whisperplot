//
// Created by christian on 6/24/21.
//

#ifndef WHISPERPLOT_PENGUIN_ENTRIES_HPP
#define WHISPERPLOT_PENGUIN_ENTRIES_HPP

#include "plotconf.hpp"
#include "packed_array.hpp"


constexpr uint128_t floorlog2(uint128_t x)
{
    return x == 1 ? 0 : 1+floorlog2(x >> 1);
}

constexpr uint128_t ceillog2(uint128_t x)
{
    return x == 1 ? 0 : floorlog2(x - 1) + 1;
}

template <uint64_t num_rows, uint128_t y_num_states, uint64_t mean_total_entries, uint8_t squares>
class BasePenguinEntry
{
    static constexpr uint64_t GetMaxEntries()
    {
        if (num_rows == 1)
        {
            return mean_entries_per_row;
        }
        else if (mean_entries_per_row < 10)
        {
            return mean_entries_per_row*10;
        }
        else if (mean_entries_per_row < 100)
        {
            return mean_entries_per_row*2;
        }
        else
        {
            return mean_entries_per_row*1.4;
        }
    }


    uint64_t row = 0;
protected:
    uint128_t y = 0;
    static constexpr uint64_t getMaxStoredY()
    {
        if (squares > 0)
        {
            return y_num_states;
        }
        else
        {
            return y_num_states / num_rows;
        }
    }

    static constexpr uint64_t getTrimmedYLenBits()
    {
        if (squares > 0)
        {
            return ceillog2(y_num_states);
        }
        else
        {
            return ceillog2(y_num_states / num_rows);
        }
    }
public:
    static const constexpr uint64_t mean_entries_per_row = mean_total_entries/num_rows;

    static const constexpr uint8_t bit_alignment = 32;

    static const constexpr uint64_t num_rows_v = num_rows;
    static const constexpr uint64_t len_bits = (getTrimmedYLenBits() == 0) ? 1 : getTrimmedYLenBits();
    static const constexpr uint64_t max_entries_per_row = GetMaxEntries();
    BasePenguinEntry() = default;

    static constexpr uint64_t getMaxY()
    {
        return y_num_states-1;
    }

    inline uint64_t getRow()
    {
        if (squares > 0)
        {
            return getRowFromY(y);
        }
        else
        {
            return row;
        }
    }

    inline void setRow(uint64_t row_in)
    {
        if (squares > 0)
        {
            // Not used
        }
        else
        {
            row = row_in;
        }
    }

    static constexpr uint64_t getRowFromY(uint128_t y_value)
    {
        if (squares > 0)
        {
            uint128_t key_value = y_value;
            uint128_t key_value_max = y_num_states;

            for (uint8_t i = 0; i < squares; i++)
            {
                // clip to at most the top 32 bits so we don't overflow when we square
                uint128_t clip_divisor = key_value_max/(1ULL << 32);
                if (clip_divisor == 0)
                {
                    clip_divisor = 1;
                }
                key_value = key_value/clip_divisor;
                key_value_max = key_value_max/clip_divisor;
                key_value = key_value*(key_value-1);
                key_value_max = key_value_max*(key_value_max-1);
            }
            uint64_t squared_row_divisor = key_value_max/((uint64_t)num_rows);
            return key_value/squared_row_divisor;
        }
        else
        {
            return y_value/(y_num_states / num_rows);
        }
    }

    static constexpr uint128_t getFirstYInRow(uint64_t row_id)
    {
        if (squares > 0)
        {
            throw std::logic_error("Not implemented!");
        }
        else
        {
            return (y_num_states / num_rows)*row_id;
        }
    }

    inline explicit BasePenguinEntry(uint128_t value_in)
    {
        setY(value_in);
    }
    inline uint128_t getY()
    {
        if (squares > 0)
        {
            return y;
        } else
        {
            return y + (y_num_states / num_rows)*row;
        }
    }
    inline void setY(uint128_t value)
    {
        assert(value < y_num_states);
        if (squares > 0)
        {
            y = value;
        } else
        {
            row = value/(y_num_states / num_rows);
            y = value%(y_num_states / num_rows);
        }
    }
/*
    inline virtual void pack(uint8_t * dest, uint64_t offset)
    {
        assert(y < getMaxStoredY());
        std::span<uint8_t> s{dest, (offset + len_bits + 7)/8};
        bitpacker::insert(s, offset, len_bits,  y);
    }

    inline virtual void unpack(uint8_t * src, uint64_t offset)
    {
        std::span<uint8_t> s{src, (offset + len_bits + 7)/8};
        y = bitpacker::extract<uint128_t>(s, offset, len_bits);
    }*/
};

// Generated by table_index and consumed by table_index+1
template<PlotConf conf, int8_t table_index>
class FwdYCEntry
{
public:
    static const constexpr uint16_t num_bc_buckets_per_row = 512;
    static const constexpr uint64_t row_divisor = kBC*num_bc_buckets_per_row;
    static const constexpr uint64_t getRowFromY(uint64_t y)
    {
        return y/row_divisor;
    }
    static const constexpr uint64_t num_rows = getRowFromY(conf.getMaxY(table_index))+1;
    static const constexpr uint64_t max_entries_per_bc_bucket = (table_index < 5) ? 350 : 350*64;
    static const constexpr uint64_t max_overlaps_per_row = max_entries_per_bc_bucket;
    static const constexpr uint64_t max_entries_per_row = max_entries_per_bc_bucket*num_bc_buckets_per_row;
    static const constexpr uint64_t c_len_bytes = (conf.getCLen(table_index) + 7) / 8;
    static const constexpr uint64_t packed_y_len_bits = ceillog2(row_divisor);
    static const constexpr uint64_t gid_len_bits = ceillog2(conf.getMaxGID(table_index));

    struct entryWithC
    {
        uint64_t packed_y : packed_y_len_bits;
        uint128_t gid : gid_len_bits;
        uint8_t c[c_len_bytes];
    };

    struct entryWithoutC
    {
        uint64_t packed_y : packed_y_len_bits;
        uint128_t gid : gid_len_bits;
    };

    using entry_struct = typename std::conditional<(c_len_bytes > 0), entryWithC, entryWithoutC>::type;

    entry_struct* data;

    static const constexpr uint64_t len_bytes = sizeof(entry_struct);
    static const constexpr uint64_t len_bits = len_bytes*8;

    const uint64_t entry_id;
    const uint64_t row_id;

    inline uint64_t getY()
    {
        return row_divisor*row_id + data->packed_y;
    }

    inline void setY(uint64_t y)
    {
        data->packed_y = y % row_divisor;
    }

    inline FwdYCEntry(void* data_in, uint64_t entry_id_in, uint64_t row_id_in):
    data((entry_struct*) ((uint8_t*)data_in + entry_id_in*len_bytes)),
    entry_id(entry_id_in),
    row_id(row_id_in)
    {}
};


// Generated by table_index and consumed by table_index+1
template<PlotConf conf, int8_t table_index>
class FwdGIDEntry
{
public:
    static uint64_t getRowFromY(uint64_t y)
    {
        uint128_t key_value = y;
        uint128_t key_value_max = conf.getMaxGID(table_index);

        for (uint8_t i = 0; i < table_index; i++)
        {
            // clip to at most the top 32 bits so we don't overflow when we square
            uint128_t clip_divisor = key_value_max/(1ULL << 32);
            if (clip_divisor == 0)
            {
                clip_divisor = 1;
            }
            key_value = key_value/clip_divisor;
            key_value_max = key_value_max/clip_divisor;
            key_value = key_value*(key_value-1);
            key_value_max = key_value_max*(key_value_max-1);
        }
        uint64_t squared_row_divisor = key_value_max/((uint64_t)num_rows);
        return key_value/squared_row_divisor;
    }
    static const constexpr uint64_t num_rows = 1ULL << 14;
    static const constexpr uint64_t max_overlaps_per_row = 0;
    static const constexpr uint64_t max_entries_per_row = 1ULL << 18;
    static const constexpr uint64_t gid_len_bits = ceillog2(conf.getMaxGID(table_index));
    static const constexpr uint64_t right_gid_len_bits = ceillog2(conf.getMaxGID(table_index-1));

    struct entryWithRightGID
    {
        uint128_t gid : gid_len_bits;
        uint128_t right_gid : right_gid_len_bits;
    };

    using entry_struct = entryWithRightGID;

    entry_struct* data;

    static const constexpr uint64_t len_bytes = sizeof(entry_struct);
    static const constexpr uint64_t len_bits = len_bytes*8;

    const uint64_t entry_id;
    const uint64_t row_id;

    inline uint128_t getY()
    {
        return data->gid;
    }

    inline void setY(uint128_t y)
    {
        data->gid = y;
    }

    inline FwdGIDEntry(void* data_in, uint64_t entry_id_in, uint64_t row_id_in):
            data((entry_struct*) ((uint8_t*)data_in + entry_id_in*len_bytes)),
            entry_id(entry_id_in),
            row_id(row_id_in)
    {}
};


#endif //WHISPERPLOT_PENGUIN_ENTRIES_HPP
