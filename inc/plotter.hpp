#ifndef PHASE1_HPP
#define PHASE1_HPP

#include <iostream>
#include <vector>
#include "penguin.hpp"
#include "buffer.hpp"
#include "park.hpp"
#include "plotter.hpp"
#include "packed_array.hpp"
#include "thread_mgr.hpp"

struct PlotConf {
    const uint8_t K;
    const uint32_t num_rows;
    const uint32_t interlace_factor;

    constexpr PlotConf(uint8_t K_in,
        uint32_t num_rows_in,
        uint32_t interlace_factor_in):
        K(K_in),
        num_rows(num_rows_in),
        interlace_factor(interlace_factor_in)
    {}

    static constexpr uint8_t max_gid_stub_val = 26;

    constexpr uint64_t getMaxEntriesForGraphTable() const
    {
        return (1ULL << K) * 1.1;
    }

    constexpr uint64_t getMeanEntriesForGraphTable() const
    {
        return 1ULL << K;
    }

    constexpr uint64_t GetMaxY(int8_t table_index) const
    {
        if (table_index < 5)
            return 1ULL << (K+kExtraBits);
        else
            return 1ULL << K;
    }

    constexpr uint128_t GetMaxGID(int8_t table_index) const {
        if (table_index == -1) {
            return (1ULL << K);
        }
        else
        {
            return GetMaxGID(table_index-1)*max_gid_stub_val;
        }
    }

    constexpr uint64_t GetCLen(int8_t table_index) const
    {
        switch (table_index)
        {
            case -1:
                return K;
            case 0:
                return K*2;
            case 1:
            case 2:
                return K*4;
            case 3:
                return K*3;
            case 4:
                return K*2;
            default:
                return 0;
        }
    }

};




// Generated by table_index and consumed by table_index+1
template<PlotConf conf, int8_t table_index>
class FwdYCEntry : public PackedEntry<conf.num_rows, conf.GetMaxY(table_index), conf.getMeanEntriesForGraphTable(), 0>
{
    using parent = PackedEntry<conf.num_rows, conf.GetMaxY(table_index), conf.getMeanEntriesForGraphTable(), 0>;
public:
    static const constexpr uint64_t c_len_bytes = (conf.GetCLen(table_index)+7)/8;
    static const constexpr uint64_t packed_y_len_bytes = (parent::getTrimmedYLenBits()+7)/8;
    static const constexpr uint64_t gid_len_bytes = (ceillog2(conf.GetMaxGID(table_index))+7)/8;

    static const constexpr uint64_t len_bits = (packed_y_len_bytes + c_len_bytes + gid_len_bytes)*8;
    uint8_t c[c_len_bytes];
    uint128_t gid;
    inline void pack(uint8_t * dest, uint64_t offset) override
    {
        assert(this->y < parent::getMaxStoredY());

        dest += offset/8;

        memcpy(dest, &this->y, packed_y_len_bytes);
        dest += packed_y_len_bytes;

        memcpy(dest, c, c_len_bytes);
        dest += c_len_bytes;

        assert(gid < conf.GetMaxGID(table_index));
        memcpy(dest, &gid, gid_len_bytes);

    }

    inline void unpack(uint8_t * src, uint64_t offset) override
    {
        src += offset/8;

        this->y = 0;
        memcpy(&this->y, src, packed_y_len_bytes);
        src += packed_y_len_bytes;

        memcpy(c, src, c_len_bytes);
        src += c_len_bytes;

        gid = 0;
        memcpy(&gid, src, gid_len_bytes);
    }
};

template<PlotConf conf, int8_t table_index>
struct FwdYCEntryCompare
{
   bool operator() (const FwdYCEntry<conf, table_index>& lhs, const FwdYCEntry<conf, table_index>& rhs) const
   {
       return lhs.gid < rhs.gid;
   }
};

// Generated by table_index
template <PlotConf conf, int8_t table_index>
class FwdGIDEntry : public PackedEntry<conf.num_rows, conf.GetMaxGID(table_index), conf.getMeanEntriesForGraphTable(), table_index+1>
{
    using parent = PackedEntry<conf.num_rows, conf.GetMaxGID(table_index), conf.getMeanEntriesForGraphTable(), table_index+1>;
public:

    uint128_t right_gid;

    inline explicit FwdGIDEntry() :
        parent(0),
        right_gid(0)
    {}

    static constexpr uint64_t packed_y_len_bytes = (parent::getTrimmedYLenBits()+7)/8;
    static constexpr uint64_t gid_len_bytes = (ceillog2(conf.GetMaxGID(table_index))+7)/8;
    static constexpr uint64_t len_bits = (packed_y_len_bytes + gid_len_bytes)*8;
    static constexpr uint64_t max_entries_per_row = (conf.getMeanEntriesForGraphTable()*3)/conf.num_rows;

    inline void pack(uint8_t * dest, uint64_t offset) override
    {
        assert(this->y < parent::getMaxStoredY());
        assert(right_gid < conf.GetMaxGID(table_index));
        dest += offset/8;

        memcpy(dest, &this->y, packed_y_len_bytes);
        dest += packed_y_len_bytes;

        memcpy(dest, &right_gid, gid_len_bytes);
    }

    inline void unpack(uint8_t * src, uint64_t offset) override
    {
        src += offset/8;
        this->y = 0;
        right_gid = 0;

        memcpy(&this->y, src, packed_y_len_bytes);
        src += packed_y_len_bytes;

        memcpy(&right_gid, src, gid_len_bytes);
    }
};


//uint8_t getK(std::string plot_fname);

template <PlotConf conf>
class Plotter
{
public:

    class Context
    {
    public:
        Plotter<conf>* plotter;
        std::vector<uint32_t> cpu_ids;
        uint32_t numa_node;
        std::vector<void*> forward_pass_gid_penguins;
        Penguin<FwdYCEntry<conf, 5>, conf.interlace_factor>* forward_pass_final_yc_penguin;

        inline Context(Plotter<conf>* plotter_in, std::vector<uint32_t> cpu_ids_in, uint32_t numa_node_in):
            plotter(plotter_in),
            cpu_ids(cpu_ids_in),
            numa_node(numa_node_in)
        {
            forward_pass_gid_penguins.resize(6);
        }

        Penguin<FwdYCEntry<conf, -1>, conf.interlace_factor>* createFirstTable();
        template <uint8_t table_index>
        Penguin<FwdYCEntry<conf, table_index>, conf.interlace_factor>* createTable(
                std::vector<Penguin<FwdYCEntry<conf, table_index-1>, conf.interlace_factor>*> prev_penguins,
                std::atomic<uint64_t>& num_matches_out
                );
    };

    inline Plotter(std::vector<uint32_t> cpu_ids_in)
    {
        for (auto & numa_node : GetNUMANodesFromCpuIds(cpu_ids_in))
        {
            std::vector<uint32_t> cpu_ids_for_context;
            for (auto & cpu_id : cpu_ids_in)
            {
                if (numa_node_of_cpu(cpu_id) == (int)numa_node)
                {
                    cpu_ids_for_context.push_back(cpu_id);
                }
            }
            contexts.push_back(new Context(this, cpu_ids_for_context, numa_node));
        }
    }

    void create(std::array<uint8_t, 32> id_in);
    //void write(std::string filename, vector<uint8_t> memo);

    //void read(std::string plot_fname, bool decompress=true);
    int32_t find_proofs(uint128_t challenge);
    void find_many_proofs(uint32_t n);

    std::vector<Context*> contexts;
    std::atomic<uint64_t> coordinator;

private:
    Buffer* output_buffer;
    std::vector<uint8_t> memo;
    std::array<uint8_t, 32> id;
    std::string filename;



    uint64_t final_table_begin_pointers[10];
    uint64_t pointer_table_offset;


    template <int8_t table_index>
    void readGraphTable(std::ifstream& file_stream, bool decompress);

    void readFinalTable(std::ifstream& file_stream);

    template<uint8_t table_index>
    uint8_t check_match_and_return_values(uint128_t gid_x, uint64_t& y, uint128_t& c);
};



#endif
